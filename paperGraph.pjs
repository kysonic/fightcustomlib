//Define Application NameSpace

App = function()
{
// ### Stage Object ###
var Stage = function (height,width,fillColor) {
// Define Stage property

   this.width = width;
   this.height = height;
   this.fillColor = fillColor;
   this.strokeColor = '#000';
   this.stokeWidth = 2;
   this.scaleOffset = 20;
   this.rotateCenter = new Point(20,330);

// Use the paperJS standart Point object

   this.startPoint = new Point(0,0);
   this.rotate = 0;

// Defain Global Path - View of the Graph Stage

   var path = new Path.Rectangle(this.startPoint,new Size(this.width,this.height));

// Stage initialaize
   this.init = function() {
        path.strokeColor = this.strokeColor;
        path.fillColor = this.fillColor;
        path.strokeWidth = this.strokeWidth;
        path.rotate(this.rotate,this.rotateCenter);
   }

    this.doRotate = function(rotate) {
        this.rotate = rotate;
        path.rotate(this.rotate,this.scaleX.scaleCenter);  
        this.scaleX.doRotate(this.rotate);
        this.scaleY.doRotate(this.rotate);
    }
    this.draw = function() {
            path.remove();
            path = new Path.Rectangle(this.startPoint,new Size(this.width,this.height));
            this.init();
            this.scaleX.draw();
            this.scaleY.draw();
     }
     
     
    this.scaleX = new App.Scale(this,new Point(this.scaleOffset,0));
    this.scaleX.init();
    this.scaleY = new App.Scale(this,new Point(0,this.scaleOffset)); 
    this.scaleY.init();

}
// ### Stage Object ###


// ### Triangle Object ###

var Triangle = function(superclass,center,delta,direction,text,rotate,viewPoints) {
    this.center = center;
    this.delta = delta;
    this.strokeColor = '#000';
    this.fillColor = '#000';
    this.rotate = superclass.rotate;   
    this.rotateCenter = superclass.rotateCenter;
    this.direct = direction;
    this.text = text;
    this.xTextOffset = 2;
    this.yTextOffset = 0;
    // Define the triangle point, he creating depending on direction 
    var point1,point2,point3;
    
    var path = new Path();
    var textPoint = new PointText();

    this.init = function() {
        switch(this.direct) {
            case 'top':
                point1 = new Point(center.x-delta,center.y+delta);
                point2 = new Point(center.x+delta,center.y+delta);
                point3 = new Point(center.x,center.y-delta);
            break;
            case 'right': 
                point1 = new Point(center.x-delta,center.y+delta);
                point2 = new Point(center.x-delta,center.y-delta);
                point3 = new Point(center.x+delta,center.y);
            break
        }
        path.add(point1);
        path.add(point2);
        path.add(point3);
        path.rotate(superclass.rotate,this.rotateCenter);

      
       // Draw Text
        if(!Fight.isEmpty(this.text)) {
            textPoint.remove();
            textPoint = new PointText(new Point(center.x+delta*this.xTextOffset,center.y-delta*this.yTextOffset));
            textPoint.content = this.text;
            textPoint.rotate(superclass.rotate,this.rotateCenter);
            textPoint.style = {
                fontSize: 15,
                fillColor: 'black',
                justification: 'center'
            };
        }

        path.strokeColor = this.strokeColor;
        path.fillColor = this.fillColor;
    
        path.closed = true;

    // Draw peak's
        if(viewPoints) {
            var circle = new Path.Circle(center,2);
            circle.fillColor = '#FF0055';

            var circle = new Path.Circle(point1,2)
            circle.fillColor = '#FF0055';

            var circle = new Path.Circle(point2,2)
            circle.fillColor = '#FF0055';

            var circle = new Path.Circle(point3,2)
            circle.fillColor = '#FF0055';

            path.storkeColor = this.strokeColor;
            path.fillColor = this.fillColor;
        }
        
       
    }
    // Draw
    this.draw = function() {
            path.remove();
            path = new Path();
            this.init();
        }
}

// ### Triangle Object ###

// ### Stroke Object ###

var Stroke = function(scale,point,size,orientation) {
    this.strokeColor = '#000';
    this.point = point;
    this.size = size;
    this.rotate = 0;
    this.orient = orientation;
    
    var path = new Path();

    this.init = function() {
      if(this.orient == 'vertical'){  
        path.add(point.x-size,point.y);
        path.add(point.x+size,point.y);
      }else {
        path.add(point.x,point.y-size);
        path.add(point.x,point.y+size);    
      }
      path.strokeColor = this.strokeColor;
      path.rotate(scale.rotate,scale.rotateCenter);
    }

    this.draw = function() {
        path.remove();
        path = new Path();
        this.init();
    }

}


// ### Stroke Object ###

// ### Scale Object ###
var Scale = function(stage,offset) {
    // Define scale property
    var superclass = stage;
    this.offset = offset;
    this.rotate = 0;
    this.part = 3;
    this.strokeColor = '#000';
    this.rotateCenter = stage.rotateCenter;
    
    // This function define scale orientation depending on entering params, exactly from offset
    this.defineScaleOrientation = function() {
        if(Fight.isEmpty(this.offset.x)) return 'y';
        if(Fight.isEmpty(this.offset.y)) return 'x';
    }

    

    var scaleOrientation = this.defineScaleOrientation();
    this.startPoint = (scaleOrientation == 'x') ? new Point(offset.x,offset.x) : new Point(offset.x+offset.y,superclass.height-offset.y);
    this.endPoint = (scaleOrientation == 'x') ? new Point(offset.x,superclass.height-offset.x) : new Point(superclass.width-offset.y,superclass.height-offset.y);
    this.scaleCenter = (scaleOrientation == 'x') ? this.endPoint : this.startPoint;

    
    
    var path = new Path();
    this.init =  function() {
        path.strokeColor = this.strokeColor;
        path.add(new Point(this.startPoint));
        path.add(new Point(this.endPoint));
        this.rotate = superclass.rotate;
        path.rotate(this.rotate,superclass.rotateCenter);
    }


    this.doRotate = function(rotate) {
        this.rotate = rotate;
        path.rotate(this.rotate,this.scaleCenter); 
    }

    this.draw = function() {
        path.remove();
        path = new Path();
        this.init();
        this.triXY.draw();
        if (scaleOrientation == 'x') {
            for(var i=1;i<this.part;i++) {
                this.tmpStroke['stroke'+i].draw();
            }
        }
        //this.tmpStroke.draw();
        
    }
    // Draw triangle's
    this.triXY = (scaleOrientation == 'x') ? new App.Triangle(superclass,this.startPoint,7,'top','x',0,false) : new App.Triangle(superclass,this.endPoint,7,'right','y',0,false);
    this.triXY.init();

    // Draw All Stroke on X Scale
    if(scaleOrientation == 'x') {
       var scaleLength = this.endPoint.y - this.startPoint.y;
       var delta = Math.round(scaleLength/this.part);
       this.tmpStroke = new Array();
       for(var i=1;i<this.part;i++) {
            this.tmpStroke['stroke'+i]= new App.Stroke(this,new Point(this.startPoint.x,this.startPoint.y+delta*i),8,'vertical');
            this.tmpStroke['stroke'+i].init();
        }

    }
}
// ### Scale Object ###



Fight.extend(Stage,Path.Rectangle);


// Return section
   return {
       Stage: Stage,
       Scale: Scale,
       Triangle: Triangle,
       Stroke: Stroke
   }
}();

// Get canvas id
var canvas = document.getElementById('paperGraph');

var stage = new App.Stage(canvas.height,canvas.width,canvas.getAttribute('color'));
stage.init();
stage.draw();

// Stage shake

var k=0;
function onFrame(event) {
    // Made a not ending cicle

    if(event.count>(100*(k+1))) {
        k++;
    }
    stage.fillColor = new Color((event.count-100*k)/100,1-((event.count-100*k)/100), (event.count-100*k)/100);
    stage.rotate++;
    stage.draw();
}












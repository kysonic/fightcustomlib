//Define Application NameSpace

App = function()
{
// ### Stage Object ###
var Stage = function (height,width,fillColor,partX,partY) {
// Define Stage property

   this.width = width;
   this.height = height;
   this.fillColor = fillColor;
   this.strokeColor = '#000';
   this.stokeWidth = 2;
   this.scaleOffset = 20;
   this.partX = partX;
   this.partY = partY;
   this.rotateCenter = new Point(20,380);
   this.data = new Object;

// Use the paperJS standart Point object

   this.startPoint = new Point(0,0);
   this.rotate = 0;

// Defain Global Path - View of the Graph Stage

   var path = new Path.Rectangle(this.startPoint,new Size(this.width,this.height));

// Stage initialaize
   this.init = function() {
        path.strokeColor = this.strokeColor;
        path.fillColor = this.fillColor;
        path.strokeWidth = this.strokeWidth;
        path.rotate(this.rotate,this.rotateCenter);
   }

    this.doRotate = function(rotate) {
        this.rotate = rotate;
        path.rotate(this.rotate,this.scaleX.scaleCenter);  
        this.scaleX.doRotate(this.rotate);
        this.scaleY.doRotate(this.rotate);
    }
    this.draw = function() {
            path.remove();
            path = new Path.Rectangle(this.startPoint,new Size(this.width,this.height));
            this.init();
            this.scaleX.draw();
            this.scaleY.draw();
            this.graph.draw();
     }
     
     
    this.scaleX = new App.Scale(this,new Point(this.scaleOffset,0));
    this.scaleX.init();
    this.scaleY = new App.Scale(this,new Point(0,this.scaleOffset)); 
    this.scaleY.init();

    // Initialize Graph
    this.initGraph = function(data) {
        this.data = data;
        this.graph = new App.Graph(this,data);
        this.graph.init();
    }

}
// ### Stage Object ###


// ### Triangle Object ###

var Triangle = function(superclass,center,delta,direction,text,rotate,viewPoints) {
    this.center = center;
    this.delta = delta;
    this.strokeColor = '#000';
    this.fillColor = '#000';
    this.rotate = superclass.rotate;   
    this.rotateCenter = superclass.rotateCenter;
    this.direct = direction;
    this.text = text;
    this.xTextOffset = 2;
    this.yTextOffset = 0;
    // Define the triangle point, he creating depending on direction 
    var point1,point2,point3;
    
    var path = new Path();
    var textPoint = new PointText();

    this.init = function() {
        switch(this.direct) {
            case 'top':
                point1 = new Point(center.x-delta,center.y+delta);
                point2 = new Point(center.x+delta,center.y+delta);
                point3 = new Point(center.x,center.y-delta);
            break;
            case 'right': 
                point1 = new Point(center.x-delta,center.y+delta);
                point2 = new Point(center.x-delta,center.y-delta);
                point3 = new Point(center.x+delta,center.y);
            break
        }
        path.add(point1);
        path.add(point2);
        path.add(point3);
        path.rotate(superclass.rotate,this.rotateCenter);

      
       // Draw Text
        if(!Fight.isEmpty(this.text)) {
            textPoint.remove();
            textPoint = new PointText(new Point(center.x+delta*this.xTextOffset,center.y-delta*this.yTextOffset));
            textPoint.content = this.text;
            textPoint.rotate(superclass.rotate,this.rotateCenter);
            textPoint.style = {
                fontSize: 15,
                fillColor: 'black',
                justification: 'center'
            };
        }

        path.strokeColor = this.strokeColor;
        path.fillColor = this.fillColor;
    
        path.closed = true;

    // Draw peak's
        if(viewPoints) {
            var circle = new Path.Circle(center,2);
            circle.fillColor = '#FF0055';

            var circle = new Path.Circle(point1,2)
            circle.fillColor = '#FF0055';

            var circle = new Path.Circle(point2,2)
            circle.fillColor = '#FF0055';

            var circle = new Path.Circle(point3,2)
            circle.fillColor = '#FF0055';

            path.storkeColor = this.strokeColor;
            path.fillColor = this.fillColor;
        }
        
       
    }
    // Draw
    this.draw = function() {
            path.remove();
            path = new Path();
            this.init();
        }
}

// ### Triangle Object ###

// ### Stroke Object ###

var Stroke = function(scale,point,size,orientation) {
    this.strokeColor = '#000';
    this.point = point;
    this.size = size;
    this.rotate = 0;
    this.orient = orientation;
    
    var path = new Path();

    this.init = function() {
      if(this.orient == 'vertical'){  
        path.add(this.point.x-this.size,this.point.y);
        path.add(this.point.x+this.size,this.point.y);
      }else {
        path.add(this.point.x,this.point.y-this.size);
        path.add(this.point.x,this.point.y+this.size);    
      }
      path.strokeColor = this.strokeColor;
      path.rotate(scale.rotate,scale.rotateCenter);
    }

    this.draw = function() {
        path.remove();
        path = new Path();
        this.init();
    }

}


// ### Stroke Object ###

// ### Scale Object ###
var Scale = function(stage,offset) {
    // Define scale property
    var superclass = stage;
    this.offset = offset;
    this.rotate = 0;
    this.partX = stage.partX;
    this.partY = stage.partY;
    this.strokeColor = '#000';
    this.rotateCenter = stage.rotateCenter;
    
    // This function define scale orientation depending on entering params, exactly from offset
    this.defineScaleOrientation = function() {
        if(Fight.isEmpty(this.offset.x)) return 'y';
        if(Fight.isEmpty(this.offset.y)) return 'x';
    }

    

    var scaleOrientation = this.defineScaleOrientation();
    this.startPoint = (scaleOrientation == 'x') ? new Point(offset.x,offset.x) : new Point(offset.x+offset.y,superclass.height-offset.y);
    this.endPoint = (scaleOrientation == 'x') ? new Point(offset.x,superclass.height-offset.x) : new Point(superclass.width-offset.y,superclass.height-offset.y);
    this.scaleCenter = (scaleOrientation == 'x') ? this.endPoint : this.startPoint;

    
    
    var path = new Path();
    this.init =  function() {
        path.strokeColor = this.strokeColor;
        path.add(new Point(this.startPoint));
        path.add(new Point(this.endPoint));
        this.partX = superclass.partX;
        this.partY = superclass.partY;
        this.rotate = superclass.rotate;
        path.rotate(this.rotate,superclass.rotateCenter);
        
    }


    this.doRotate = function(rotate) {
        this.rotate = rotate;
        path.rotate(this.rotate,this.scaleCenter); 
    }

    this.draw = function() {
        path.remove();
        path = new Path();
        this.init();
        this.triXY.draw();
        if (scaleOrientation == 'x') {
            this.scaleLengthX = this.endPoint.y - this.startPoint.y;
            this.deltaX = Math.round(this.scaleLengthX/this.partX);
            for(var i=1;i<this.partX;i++) {
                if(this.tmpStrokeX['stroke'+i]!=undefined) {
                    this.tmpStrokeX['stroke'+i].point = new Point(this.startPoint.x,this.startPoint.y+this.deltaX*i);
                    this.tmpStrokeX['stroke'+i].draw();
                }else {
                    this.tmpStrokeX['stroke'+i]= new App.Stroke(this,new Point(this.startPoint.x,this.startPoint.y+this.deltaX*i),8,'vertical');
                    this.tmpStrokeX['stroke'+i].init();
                }
            }
        }else {
            this.scaleLengthY = this.endPoint.x - this.startPoint.x;
            this.deltaY = Math.round(this.scaleLengthY/this.partY);
            for(var i=1;i<this.partY;i++) {
               if(this.tmpStrokeY['stroke'+i]!=undefined) {
                    this.tmpStrokeY['stroke'+i].point = new Point(this.startPoint.x+this.deltaY*i,this.startPoint.y);
                    this.tmpStrokeY['stroke'+i].draw();
                }else {
                    this.tmpStrokeY['stroke'+i]= new App.Stroke(this,new Point(this.startPoint.x+this.deltaY*i,this.startPoint.y),8,'gorizontal');
                    this.tmpStrokeY['stroke'+i].init();
                }
            }
        }
        //this.tmpStrokeX.draw();
        
    }
    // Draw triangle's
    this.triXY = (scaleOrientation == 'x') ? new App.Triangle(superclass,this.startPoint,7,'top','x',0,false) : new App.Triangle(superclass,this.endPoint,7,'right','y',0,false);
    this.triXY.init();

                 // Draw All Stroke on X Scale
        if(scaleOrientation == 'x') {
            this.scaleLengthX = this.endPoint.y - this.startPoint.y;
            this.deltaX = Math.round(this.scaleLengthX/this.partX);
            this.tmpStrokeX = new Array();
            for(var i=1;i<this.partX;i++) {
                this.tmpStrokeX['stroke'+i]= new App.Stroke(this,new Point(this.startPoint.x,this.startPoint.y+this.deltaX*i),8,'vertical');
                this.tmpStrokeX['stroke'+i].init();
        }

    } else {
       this.scaleLengthY = this.endPoint.x - this.startPoint.x;
       this.deltaY = Math.round(this.scaleLengthY/this.partY);
       this.tmpStrokeY = new Array();
       for(var i=1;i<this.partY;i++) {
            this.tmpStrokeY['stroke'+i]= new App.Stroke(this,new Point(this.startPoint.x+this.deltaY*i,this.startPoint.y),8,'gorizontal');
            this.tmpStrokeY['stroke'+i].init();
        }
    }

   

    
}
// ### Scale Object ###

// ### Graph Object ###

var Graph = function(stage,data) {
    this.points = data.points;
    this.rotate = stage.rotate;
    this.pointRad = 3;
    this.pointStrokeColor = 'black';
    this.pointFillColor = 'black';
    this.storkeColor = 'black';

    var path = new Path();

    var points = new Array();
   
    this.init = function() {
            this.nullPoint = stage.scaleX.endPoint;
    this.deltaX = stage.scaleX.deltaX;
    this.deltaY = stage.scaleY.deltaY;
        for (var i=0;i<this.points.length;i++) {
            points[i] = new Path.Circle(new Point(this.nullPoint.x+this.deltaY*this.points[i].x,this.nullPoint.y-this.deltaX*this.points[i].y),this.pointRad);
            points[i].strokeColor = this.pointStrokeColor;
            points[i].fillColor = this.pointFillColor;
            points[i].rotate(stage.rotate,stage.rotateCenter);
        }
        this.drawLine();
    }

    this.draw = function() {
        for (var i=0;i<this.points.length;i++) {
            points[i].remove();
        }
        this.init();
    }
    

    this.drawLine = function() {
         path.remove();
         path = new Path();
         path.selected = true;
         for (var i=0;i<this.points.length;i++) {
            path.add(new Point(this.nullPoint.x+this.deltaY*this.points[i].x,this.nullPoint.y-this.deltaX*this.points[i].y)); 
        }
        path.strokeColor = this.storkeColor;
        path.strokeWidth = 5;
        path.strokeColor._alpha=0.2;
        path.rotate(stage.rotate,stage.rotateCenter);
    }
    
}

// ### Graph Object ###


// Return section
   return {
       Stage: Stage,
       Scale: Scale,
       Triangle: Triangle,
       Stroke: Stroke,
       Graph: Graph
   }
}();

// Get canvas id
var canvas = document.getElementById('paperGraph');


var stage;
var loading = new PointText(view.center);
    loading.content = 'Loading...';
    loading.style = {
                fontSize: 40,
                fillColor: 'red',
                justification: 'center'
            };
$.getJSON('points.json',function(response) {
    stage = new App.Stage(canvas.height,canvas.width,canvas.getAttribute('color'),response.scaleX,response.scaleY);
    stage.init();
    stage.initGraph(response);
    loading.remove();
});

// Add On Mouse Wheel Event - scale us graph!

Fight.addEvent('wheel',function(event){
     var delta = Fight.getWheelDelta(event);
     if(delta=='1') {
       if((stage.partX+1)<30 && (stage.partY+1)<30) {
            stage.partX++;
            stage.partY++;
       }

     }else {
     if((stage.partX-1)>0 && (stage.partY-1)>0) {
        stage.partX--;
        stage.partY--;
     }
}
     
});


// Stage shake

var k=0;
function onFrame(event) {
/*
    // Made a not ending cicle

    if(event.count>(100*(k+1))) {
        k++;
    }
    stage.fillColor = new Color((event.count-100*k)/100,1-((event.count-100*k)/100), (event.count-100*k)/100);
    stage.rotate++;
*/
    stage.draw();
}

















